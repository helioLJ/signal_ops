#!/usr/bin/env node
/*
  Simple load generator for Signal Ops backend.
  - Hits /tasks (GET), /tasks (POST), /tasks/slow, /tasks/error-prone, /tasks/error-always
  - Randomizes requests and concurrency
  - Configure via env: BASE_URL, CONCURRENCY, RPS, DURATION_SEC
*/

const DEFAULT_BASE_URL = process.env.BASE_URL || 'http://localhost:3002';
const CONCURRENCY = Number(process.env.CONCURRENCY || 10); // parallel workers
const RPS = Number(process.env.RPS || 30); // target requests per second
const DURATION_SEC = Number(process.env.DURATION_SEC || 180); // total time in seconds

const headers = { 'content-type': 'application/json' };

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

function randomTaskPayload() {
  const priorities = ['low', 'medium', 'high'];
  return {
    title: `Task ${Date.now()}-${Math.random().toString(16).slice(2)}`,
    description: 'Generated by load generator',
    completed: Math.random() < 0.1,
    priority: priorities[randInt(0, priorities.length - 1)],
    dueDate: new Date(Date.now() + randInt(1, 14) * 86400000).toISOString(),
  };
}

const routes = [
  { name: 'GET /tasks', method: 'GET', path: '/tasks' },
  { name: 'POST /tasks', method: 'POST', path: '/tasks' },
  { name: 'GET /tasks/slow', method: 'GET', path: '/tasks/slow' },
  { name: 'GET /tasks/error-prone', method: 'GET', path: '/tasks/error-prone' },
  { name: 'GET /tasks/error-always', method: 'GET', path: '/tasks/error-always' },
];

async function hitOnce() {
  const choice = routes[randInt(0, routes.length - 1)];
  const url = DEFAULT_BASE_URL + choice.path;
  const init = { method: choice.method, headers };
  if (choice.method === 'POST') {
    init.body = JSON.stringify(randomTaskPayload());
  }

  const start = Date.now();
  try {
    const res = await fetch(url, init);
    const ms = Date.now() - start;
    if (!res.ok) {
      console.error(`[${ms}ms] ${choice.name} -> ${res.status}`);
    } else {
      // Avoid reading all bodies to keep it fast; sample some
      if (Math.random() < 0.05) await res.text().catch(() => {});
      console.log(`[${ms}ms] ${choice.name} -> ${res.status}`);
    }
  } catch (err) {
    const ms = Date.now() - start;
    console.error(`[${ms}ms] ${choice.name} -> ERROR: ${err.message}`);
  }
}

async function worker(stopAt) {
  const intervalMs = Math.max(1, Math.floor(1000 / (RPS / CONCURRENCY)));
  while (Date.now() < stopAt) {
    // Jitter to avoid burst alignment
    const jitter = randInt(0, Math.min(200, Math.floor(intervalMs / 2)));
    await hitOnce();
    await sleep(intervalMs + jitter);
  }
}

async function main() {
  const stopAt = Date.now() + DURATION_SEC * 1000;
  console.log(`Loadgen start -> base=${DEFAULT_BASE_URL} concurrency=${CONCURRENCY} rps=${RPS} durationSec=${DURATION_SEC}`);
  const workers = Array.from({ length: CONCURRENCY }, () => worker(stopAt));
  await Promise.all(workers);
  console.log('Loadgen done');
}

// Node 20+ has global fetch
if (typeof fetch !== 'function') {
  console.error('Node 20+ required (global fetch).');
  process.exit(1);
}

main().catch((e) => {
  console.error('Loadgen failed:', e);
  process.exit(1);
});
